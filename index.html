<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Pro Parking Simulator - Universal Fit</title>
    <style>
        body {
            background-color: #000;
            color: #ecf0f1;
            font-family: 'Segoe UI', sans-serif;
            margin: 0;
            padding: 0;
            overflow: hidden;
            width: 100vw;
            height: 100vh;
            touch-action: none;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        /* The Scaler Wrapper: 
           This holds the game content and scales it 
           to fit the screen using CSS Transforms.
        */
        #scaler {
            position: relative;
            width: 1100px;  /* INTERNAL GAME WIDTH */
            height: 700px; /* INTERNAL GAME HEIGHT */
            box-shadow: 0 0 50px rgba(0,0,0,0.5);
            background: #1a1a1a;
            transform-origin: center;
        }

        canvas {
            display: block;
            background-color: #34495e;
        }

        /* --- UI ELEMENTS (Inside Scaler) --- */
        #ui-layer {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none;
        }
        
        #top-left { position: absolute; top: 20px; left: 20px; }
        #top-right { position: absolute; top: 20px; right: 20px; text-align: right; }
        
        .hud-text {
            font-size: 20px;
            font-weight: 600;
            text-shadow: 2px 2px 0px black;
            margin-bottom: 5px;
        }
        #level-title { color: #f1c40f; font-size: 30px; font-weight: bold; }
        #level-timer { color: #e74c3c; font-size: 34px; font-family: monospace; font-weight: bold; }

        #status-msg { 
            position: absolute; 
            top: 40%; 
            width: 100%; 
            text-align: center; 
            font-size: 50px; 
            font-weight: bold;
            text-shadow: 3px 3px 0px black;
            display: none;
            z-index: 10;
        }

        #end-screen {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.95);
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 50;
        }

        /* --- CONTROLS (Overlay on top of everything) --- */
        /* These stay fixed to the physical screen edges */
        #touch-overlay {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none;
            z-index: 100;
        }

        #mobile-controls {
            position: absolute;
            bottom: 20px;
            width: 100%;
            height: 140px;
            display: flex;
            justify-content: space-between;
            padding: 0 30px;
            box-sizing: border-box;
        }

        .control-group {
            display: flex;
            gap: 20px;
            align-items: flex-end;
            pointer-events: auto;
        }

        .control-btn {
            background: rgba(255, 255, 255, 0.15);
            border: 2px solid rgba(255, 255, 255, 0.5);
            color: white;
            border-radius: 50%;
            width: 80px;
            height: 80px;
            font-size: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            user-select: none;
            -webkit-user-select: none;
            backdrop-filter: blur(4px);
            touch-action: manipulation;
        }
        .control-btn:active { background: rgba(255, 255, 255, 0.5); transform: scale(0.95); }

        #btn-gas { background: rgba(46, 204, 113, 0.4); width: 90px; height: 90px; }
        #btn-brake { background: rgba(231, 76, 60, 0.4); width: 70px; height: 70px; font-size: 20px; margin-bottom: 5px; }

        #restart-btn-fixed {
            position: fixed;
            top: 20px;
            left: 20px;
            width: 50px;
            height: 50px;
            background: rgba(230, 126, 34, 0.8);
            border-radius: 50%;
            color: white;
            font-size: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            border: 2px solid white;
            pointer-events: auto;
            z-index: 101;
            cursor: pointer;
        }

        /* Keyboard hint for PC */
        #pc-hint {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: rgba(0,0,0,0.7);
            padding: 10px;
            border-radius: 5px;
            font-size: 14px;
            color: #bdc3c7;
            pointer-events: none;
        }
        @media (max-width: 1024px) { #pc-hint { display: none; } } /* Hide on mobile */
        
        /* End Screen Table */
        table { border-collapse: collapse; margin: 10px; width: 80%; font-size: 20px; }
        th, td { border: 1px solid #7f8c8d; padding: 10px; text-align: center; color: white; }
        th { background-color: #e67e22; }
        .grade-S { color: #f1c40f; text-shadow: 0 0 10px gold; }
        .grade-A { color: #2ecc71; }
        .grade-B { color: #3498db; }
        .grade-C { color: #e67e22; }
        .grade-F { color: #e74c3c; }
        
        button.end-btn {
            padding: 15px 40px; font-size: 24px; background: #27ae60; color: white; border: none; 
            border-radius: 5px; margin-top: 20px; cursor: pointer; pointer-events: auto;
        }
    </style>
</head>
<body>

<div id="restart-btn-fixed" onclick="initLevel(levelIndex)">â†º</div>
<div id="pc-hint">ARROWS / WASD to Drive | SPACE to Brake</div>

<div id="touch-overlay">
    <div id="mobile-controls">
        <div class="control-group">
            <div class="control-btn" id="btn-left">â—€</div>
            <div class="control-btn" id="btn-right">â–¶</div>
        </div>
        <div class="control-group">
            <div class="control-btn" id="btn-brake">ðŸ›‘</div>
            <div class="control-btn" id="btn-gas">â–²</div>
        </div>
    </div>
</div>

<div id="scaler">
    <canvas id="gameCanvas" width="1100" height="700"></canvas>
    
    <div id="ui-layer">
        <div id="top-left">
            <div id="level-title">Level 1</div>
            <div id="level-hint" class="hud-text">Hint: Park in the box</div>
        </div>
        <div id="top-right">
            <div class="hud-text" style="color:#bdc3c7;">TIME</div>
            <div id="level-timer">00:00</div>
        </div>
        <div id="status-msg">PARKED!</div>
        
        <div id="end-screen">
            <h1 style="color: #f1c40f; font-size: 50px; margin: 0;">LICENSE OBTAINED!</h1>
            <h2 id="final-grade-title">Rank: S</h2>
            <div style="overflow-y: auto; max-height: 400px; width: 100%; display: flex; justify-content: center;">
                <table id="score-table">
                    <thead><tr><th>Lvl</th><th>Time</th><th>Acc</th><th>Grade</th></tr></thead>
                    <tbody id="score-body"></tbody>
                </table>
            </div>
            <button class="end-btn" onclick="restartGame()">Play Again</button>
        </div>
    </div>
</div>

<script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const scaler = document.getElementById('scaler');

    // UI Refs
    const uiLevel = document.getElementById('level-title');
    const uiHint = document.getElementById('level-hint');
    const uiTimer = document.getElementById('level-timer');
    const uiStatus = document.getElementById('status-msg');
    const endScreen = document.getElementById('end-screen');
    const scoreBody = document.getElementById('score-body');
    const finalGradeTitle = document.getElementById('final-grade-title');

    // --- SCALING ENGINE ---
    // This function calculates the scale factor to fit 1100x700 into the window
    function resizeGame() {
        const gameW = 1100;
        const gameH = 700;
        const winW = window.innerWidth;
        const winH = window.innerHeight;

        const scale = Math.min(winW / gameW, winH / gameH);
        
        scaler.style.transform = `scale(${scale})`;
    }
    window.addEventListener('resize', resizeGame);
    resizeGame(); // Initial call

    // --- GAME CONSTANTS ---
    const GAME_W = 1100;
    const GAME_H = 700;
    const CAR_W = 26;
    const CAR_H = 48;
    const PARK_W = 36;
    const PARK_H = 60;

    // --- INPUT HANDLING ---
    const keys = { ArrowUp:false, ArrowDown:false, ArrowLeft:false, ArrowRight:false, w:false, a:false, s:false, d:false, " ":false, r:false };

    window.addEventListener('keydown', e => keys[e.key] = true);
    window.addEventListener('keyup', e => {
        keys[e.key] = false;
        if(e.key.toLowerCase() === 'r') initLevel(levelIndex);
    });

    // Mobile Touch Logic
    function attachTouch(id, key) {
        const el = document.getElementById(id);
        const setKey = (val) => { keys[key] = val; };
        
        el.addEventListener('touchstart', (e) => { e.preventDefault(); setKey(true); });
        el.addEventListener('touchend', (e) => { e.preventDefault(); setKey(false); });
        // Mouse fallback for testing on PC
        el.addEventListener('mousedown', (e) => { setKey(true); });
        el.addEventListener('mouseup', (e) => { setKey(false); });
        el.addEventListener('mouseleave', (e) => { setKey(false); });
    }
    attachTouch('btn-left', 'ArrowLeft');
    attachTouch('btn-right', 'ArrowRight');
    attachTouch('btn-gas', 'ArrowUp');
    attachTouch('btn-brake', 'ArrowDown');

    // --- DRAWING ---
    function drawCar(x, y, angle, color = "#3498db", isTraffic = false) {
        ctx.save();
        ctx.translate(x, y);
        ctx.rotate(angle);

        ctx.fillStyle = "rgba(0,0,0,0.5)";
        ctx.fillRect(-CAR_W/2 + 3, -CAR_H/2 + 3, CAR_W, CAR_H);

        ctx.fillStyle = color;
        ctx.beginPath();
        ctx.roundRect(-CAR_W/2, -CAR_H/2, CAR_W, CAR_H, 4);
        ctx.fill();

        ctx.fillStyle = "#2c3e50";
        ctx.fillRect(-CAR_W/2 + 2, -CAR_H/2 + 10, CAR_W - 4, 10);
        ctx.fillRect(-CAR_W/2 + 2, CAR_H/2 - 12, CAR_W - 4, 6);

        if (!isTraffic) {
            ctx.fillStyle = "#f1c40f"; 
            ctx.fillRect(-CAR_W/2 + 2, -CAR_H/2, 6, 4);
            ctx.fillRect(CAR_W/2 - 8, -CAR_H/2, 6, 4);
            
            ctx.fillStyle = (keys.ArrowDown || keys.s || keys[" "]) ? "#ff0000" : "#7f0000";
            ctx.fillRect(-CAR_W/2 + 2, CAR_H/2 - 4, 6, 4);
            ctx.fillRect(CAR_W/2 - 8, CAR_H/2 - 4, 6, 4);
        } else {
            ctx.fillStyle = "#ecf0f1";
            ctx.fillRect(-CAR_W/2 + 2, -CAR_H/2, 6, 4);
            ctx.fillRect(CAR_W/2 - 8, -CAR_H/2, 6, 4);
            ctx.fillStyle = "#c0392b";
            ctx.fillRect(-CAR_W/2 + 2, CAR_H/2 - 4, 6, 4);
            ctx.fillRect(CAR_W/2 - 8, CAR_H/2 - 4, 6, 4);
        }
        ctx.restore();
    }

    // --- GAME LOGIC ---
    let gameState = "PLAYING"; 
    let levelIndex = 0;
    let levelResults = []; 
    let startTime = 0;
    let timerInterval = null;
    let elapsedSecs = 0;

    class Car {
        constructor(x, y, angle) {
            this.x = x; this.y = y; this.angle = angle;
            this.speed = 0; 
            this.maxSpeed = 5.2; 
            this.friction = 0.95; 
            this.accel = 0.25; 
            this.turnSpeed = 0.055; 
        }
        update() {
            if (keys.ArrowUp || keys.w) this.speed += this.accel;
            if (keys.ArrowDown || keys.s) this.speed -= this.accel;
            if (keys[" "]) this.speed *= 0.85; 

            this.speed *= this.friction;
            if (this.speed > this.maxSpeed) this.speed = this.maxSpeed;
            if (this.speed < -this.maxSpeed/2) this.speed = -this.maxSpeed/2;
            if (Math.abs(this.speed) < 0.05) this.speed = 0;

            if (Math.abs(this.speed) > 0.1) {
                const dir = this.speed > 0 ? 1 : -1;
                if (keys.ArrowLeft || keys.a) this.angle -= this.turnSpeed * dir;
                if (keys.ArrowRight || keys.d) this.angle += this.turnSpeed * dir;
            }
            this.x += Math.sin(this.angle) * this.speed;
            this.y -= Math.cos(this.angle) * this.speed;
        }
        getPolygon() { return getRotatedRect(this.x, this.y, CAR_W, CAR_H, this.angle); }
    }

    class Traffic {
        constructor(x, y, w, h, speedX, speedY) {
            this.x = x; this.y = y; this.w = w; this.h = h;
            this.vx = speedX; this.vy = speedY;
            this.angle = (Math.abs(this.vy) > Math.abs(this.vx)) ? (this.vy > 0 ? Math.PI : 0) : (this.vx > 0 ? Math.PI/2 : -Math.PI/2);
        }
        update() {
            this.x += this.vx;
            this.y += this.vy;
            // Wrap around using FIXED GAME DIMENSIONS
            if (this.x > GAME_W + 50) this.x = -50;
            if (this.x < -50) this.x = GAME_W + 50;
            if (this.y > GAME_H + 50) this.y = -50;
            if (this.y < -50) this.y = GAME_H + 50;
        }
        draw() { drawCar(this.x, this.y, this.angle, "#95a5a6", true); }
        getPolygon() { return getRotatedRect(this.x, this.y, CAR_W, CAR_H, this.angle); }
    }

    function getRotatedRect(x, y, w, h, angle) {
        const dx = w/2, dy = h/2;
        const corners = [{x:-dx, y:-dy}, {x:dx, y:-dy}, {x:dx, y:dy}, {x:-dx, y:dy}];
        return corners.map(p => ({
            x: x + (p.x * Math.cos(angle) - p.y * Math.sin(angle)),
            y: y + (p.x * Math.sin(angle) + p.y * Math.cos(angle))
        }));
    }

    function polysIntersect(poly1, poly2) {
        const polygons = [poly1, poly2];
        for (let polygon of polygons) {
            for (let i = 0; i < polygon.length; i++) {
                const p1 = polygon[i];
                const p2 = polygon[(i + 1) % polygon.length];
                const normal = { x: p2.y - p1.y, y: p1.x - p2.x }; 
                
                let minA = Infinity, maxA = -Infinity;
                for (let p of poly1) {
                    const projected = normal.x * p.x + normal.y * p.y;
                    if (projected < minA) minA = projected;
                    if (projected > maxA) maxA = projected;
                }
                let minB = Infinity, maxB = -Infinity;
                for (let p of poly2) {
                    const projected = normal.x * p.x + normal.y * p.y;
                    if (projected < minB) minB = projected;
                    if (projected > maxB) maxB = projected;
                }
                if (maxA < minB || maxB < minA) return false;
            }
        }
        return true;
    }

    // --- LEVEL DATA (All optimized for 1100x700) ---
    const levels = [
        {
            name: "1. The Basics", hint: "Drive straight in.", targetTime: 8,
            start: {x: 100, y: 550, a: 0},
            spot: {x: 100, y: 150, a: 0},
            walls: [{x: 200, y: 50, w: 20, h: 500}], 
            traffic: []
        },
        {
            name: "2. The Turn", hint: "Turn right and park.", targetTime: 12,
            start: {x: 100, y: 550, a: 0},
            spot: {x: 750, y: 400, a: Math.PI/2},
            walls: [{x: 250, y: 250, w: 400, h: 300}], 
            traffic: []
        },
        {
            name: "3. Back It Up", hint: "Reverse parking only.", targetTime: 15,
            start: {x: 450, y: 100, a: Math.PI},
            spot: {x: 450, y: 500, a: Math.PI}, 
            walls: [{x: 320, y: 300, w: 20, h: 250}, {x: 560, y: 300, w: 20, h: 250}],
            traffic: []
        },
        {
            name: "4. Static Traffic", hint: "Navigate the parked cars.", targetTime: 18,
            start: {x: 50, y: 325, a: Math.PI/2},
            spot: {x: 800, y: 325, a: Math.PI/2},
            walls: [
                {x: 200, y: 100, w: 30, h: 100}, {x: 200, y: 450, w: 30, h: 100},
                {x: 400, y: 200, w: 30, h: 250}, 
                {x: 600, y: 0, w: 30, h: 200}, {x: 600, y: 450, w: 30, h: 200}
            ],
            traffic: []
        },
        {
            name: "5. Highway Crossing", hint: "Watch out for cars!", targetTime: 10,
            start: {x: 450, y: 600, a: 0},
            spot: {x: 450, y: 50, a: 0},
            walls: [],
            traffic: [
                {x: 0, y: 200, vx: 4, vy: 0}, {x: 300, y: 200, vx: 4, vy: 0}, {x: 600, y: 200, vx: 4, vy: 0},
                {x: 100, y: 350, vx: -3, vy: 0}, {x: 400, y: 350, vx: -3, vy: 0}, {x: 700, y: 350, vx: -3, vy: 0},
            ]
        },
        {
            name: "6. Parallel Park", hint: "Fit between the barriers.", targetTime: 20,
            start: {x: 100, y: 350, a: Math.PI/2},
            spot: {x: 500, y: 150, a: Math.PI/2},
            walls: [
                {x: 0, y: 100, w: 400, h: 100}, 
                {x: 600, y: 100, w: 400, h: 100}, 
                {x: 0, y: 0, w: 1200, h: 100} 
            ],
            traffic: []
        },
        {
            name: "7. The Gauntlet", hint: "Moving traffic + Walls.", targetTime: 18,
            start: {x: 50, y: 50, a: Math.PI/2},
            spot: {x: 800, y: 550, a: Math.PI},
            walls: [{x: 300, y: 150, w: 300, h: 300}],
            traffic: [
                {x: 100, y: 100, vx: 0, vy: 2}, {x: 800, y: 500, vx: 0, vy: -2}
            ]
        },
        {
            name: "8. Diagonal Alley", hint: "Tight angled parking.", targetTime: 15,
            start: {x: 100, y: 300, a: Math.PI/2},
            spot: {x: 600, y: 150, a: Math.PI/4}, 
            walls: [
                {x: 400, y: 0, w: 20, h: 180},
                {x: 800, y: 0, w: 20, h: 300},
                {x: 500, y: 300, w: 20, h: 350}
            ],
            traffic: []
        },
        {
            name: "9. Busy Lot", hint: "Cross traffic to park.", targetTime: 20,
            start: {x: 450, y: 600, a: 0},
            spot: {x: 80, y: 300, a: -Math.PI/2},
            walls: [{x: 200, y: 100, w: 500, h: 400}], 
            traffic: [
                {x: 0, y: 50, vx: 5, vy: 0},
                {x: 900, y: 550, vx: -5, vy: 0},
                {x: 50, y: 0, vx: 0, vy: 3},
                {x: 850, y: 650, vx: 0, vy: -3}
            ]
        },
        {
            name: "10. The Impossible", hint: "Don't scratch the paint.", targetTime: 15,
            start: {x: 50, y: 50, a: Math.PI/2},
            spot: {x: 820, y: 550, a: Math.PI},
            walls: [
                {x: 200, y: 0, w: 20, h: 450},
                {x: 400, y: 200, w: 20, h: 450},
                {x: 600, y: 0, w: 20, h: 450}
            ],
            traffic: [
                {x: 250, y: 500, vx: 0, vy: -6},
                {x: 500, y: 100, vx: 0, vy: 6}
            ]
        },
        {
            name: "11. The Spiral", hint: "Follow the snail.", targetTime: 25,
            start: {x: 100, y: 550, a: 0},
            spot: {x: 450, y: 350, a: -Math.PI/2},
            walls: [
                {x: 200, y: 200, w: 20, h: 400}, 
                {x: 200, y: 200, w: 500, h: 20}, 
                {x: 700, y: 200, w: 20, h: 300}, 
                {x: 400, y: 500, w: 320, h: 20}, 
                {x: 400, y: 300, w: 20, h: 220}, 
                {x: 400, y: 300, w: 100, h: 20}, 
            ],
            traffic: []
        },
        {
            name: "12. Needle Thread", hint: "Don't touch the walls.", targetTime: 15,
            start: {x: 50, y: 325, a: Math.PI/2},
            spot: {x: 900, y: 325, a: Math.PI/2},
            walls: [
                {x: 0, y: 280, w: 1200, h: 20}, 
                {x: 0, y: 350, w: 1200, h: 20}, 
                {x: 300, y: 300, w: 10, h: 10},
                {x: 600, y: 340, w: 10, h: 10}
            ],
            traffic: []
        },
        {
            name: "13. The Maze", hint: "Zig zag.", targetTime: 30,
            start: {x: 50, y: 100, a: Math.PI/2},
            spot: {x: 900, y: 550, a: Math.PI/2},
            walls: [
                {x: 200, y: 0, w: 20, h: 450},
                {x: 450, y: 200, w: 20, h: 600},
                {x: 700, y: 0, w: 20, h: 450},
                {x: 0, y: 600, w: 200, h: 20},
                {x: 220, y: 150, w: 100, h: 20},
                {x: 550, y: 500, w: 100, h: 20}
            ],
            traffic: []
        }
    ];

    function initLevel(idx) {
        if (timerInterval) clearInterval(timerInterval);
        
        if (idx >= levels.length) {
            showEndScreen();
            return;
        }
        levelIndex = idx;
        currentLvlData = levels[idx];
        gameState = "PLAYING";

        player = new Car(currentLvlData.start.x, currentLvlData.start.y, currentLvlData.start.a);
        
        traffic = [];
        if (currentLvlData.traffic) {
            currentLvlData.traffic.forEach(t => {
                traffic.push(new Traffic(t.x, t.y, CAR_W, CAR_H, t.vx, t.vy));
            });
        }

        uiLevel.innerText = currentLvlData.name;
        uiHint.innerText = currentLvlData.hint;
        uiStatus.style.display = 'none';
        
        startTime = Date.now();
        uiTimer.innerText = "00:00";
        timerInterval = setInterval(() => {
            const delta = Date.now() - startTime;
            elapsedSecs = delta / 1000;
            const secs = Math.floor(elapsedSecs);
            const ms = Math.floor((delta % 1000) / 10);
            uiTimer.innerText = `${secs < 10 ? '0'+secs : secs}:${ms < 10 ? '0'+ms : ms}`;
        }, 50);
    }

    function checkCollision() {
        const pPoly = player.getPolygon();
        // Walls
        for (let w of currentLvlData.walls) {
            const wPoly = [{x: w.x, y: w.y}, {x: w.x+w.w, y: w.y}, {x: w.x+w.w, y: w.y+w.h}, {x: w.x, y: w.y+w.h}];
            if (polysIntersect(pPoly, wPoly)) return true;
        }
        // Traffic
        for (let t of traffic) {
            if (polysIntersect(pPoly, t.getPolygon())) return true;
        }
        // Boundaries (using fixed GAME constants, not window size)
        if (player.x < 0 || player.x > GAME_W || player.y < 0 || player.y > GAME_H) return true;
        
        return false;
    }

    function calculateGrade(acc, time, target) {
        let timePenalty = 0;
        if (time > target) timePenalty = (time - target) * 3; 
        const score = acc - timePenalty;
        if (score >= 95) return 'S';
        if (score >= 85) return 'A';
        if (score >= 70) return 'B';
        if (score >= 50) return 'C';
        if (score >= 30) return 'D';
        return 'F';
    }

    function checkWin() {
        if (Math.abs(player.speed) > 0.1) return;

        const s = currentLvlData.spot;
        const dist = Math.sqrt((player.x - s.x)**2 + (player.y - s.y)**2);
        
        let pAng = player.angle % (Math.PI*2); if (pAng < 0) pAng += Math.PI*2;
        let sAng = s.a % (Math.PI*2); if (sAng < 0) sAng += Math.PI*2;
        let angDiff = Math.abs(pAng - sAng);
        if (angDiff > Math.PI) angDiff = (Math.PI*2) - angDiff;

        if (dist < 20 && angDiff < 0.35) {
            clearInterval(timerInterval);
            gameState = "PARKED";
            
            let acc = Math.max(0, 100 - (dist * 2) - (angDiff * 50));
            acc = Math.floor(acc);
            
            const grade = calculateGrade(acc, elapsedSecs, currentLvlData.targetTime);
            levelResults.push({ level: levelIndex + 1, time: elapsedSecs.toFixed(2), acc: acc, grade: grade });

            uiStatus.innerText = `PARKED! Grade: ${grade}`;
            uiStatus.className = `grade-${grade}`; 
            uiStatus.style.color = grade === 'S' ? '#f1c40f' : (grade === 'A' ? '#2ecc71' : (grade === 'F' ? '#e74c3c' : '#3498db'));
            uiStatus.style.display = "block";
            
            setTimeout(() => { initLevel(levelIndex + 1); }, 2500);
        }
    }

    function drawScene() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // Walls
        ctx.fillStyle = "#95a5a6";
        for (let w of currentLvlData.walls) {
            ctx.fillRect(w.x, w.y, w.w, w.h);
            ctx.strokeStyle = "#7f8c8d"; ctx.lineWidth = 2; ctx.strokeRect(w.x, w.y, w.w, w.h);
        }

        // Spot
        const s = currentLvlData.spot;
        ctx.save(); ctx.translate(s.x, s.y); ctx.rotate(s.a);
        ctx.strokeStyle = "white"; ctx.lineWidth = 4;
        ctx.beginPath(); ctx.moveTo(-PARK_W/2, -PARK_H/2); ctx.lineTo(-PARK_W/2, PARK_H/2); ctx.lineTo(PARK_W/2, PARK_H/2); ctx.lineTo(PARK_W/2, -PARK_H/2); ctx.stroke();
        ctx.fillStyle = "rgba(255,255,255,0.2)"; ctx.beginPath(); ctx.moveTo(0, -20); ctx.lineTo(-10, 10); ctx.lineTo(10, 10); ctx.fill(); ctx.restore();

        traffic.forEach(t => t.draw());
        drawCar(player.x, player.y, player.angle);
    }

    function gameLoop() {
        if (gameState === "PLAYING") {
            player.update();
            traffic.forEach(t => t.update());
            if (checkCollision()) {
                gameState = "CRASHED"; clearInterval(timerInterval);
                uiStatus.innerText = "CRASHED!"; uiStatus.style.color = "#e74c3c"; uiStatus.style.display = "block";
            } else { checkWin(); }
        }
        drawScene();
        requestAnimationFrame(gameLoop);
    }

    function showEndScreen() {
        gameState = "END"; endScreen.style.display = "flex"; scoreBody.innerHTML = "";
        let gpaTotal = 0; const gpaMap = {'S':4.3, 'A':4.0, 'B':3.0, 'C':2.0, 'D':1.0, 'F':0};
        levelResults.forEach(res => {
            gpaTotal += gpaMap[res.grade] || 0;
            const tr = document.createElement('tr');
            tr.innerHTML = `<td>${res.level}</td><td>${res.time}s</td><td>${res.acc}%</td><td class="grade-${res.grade}">${res.grade}</td>`;
            scoreBody.appendChild(tr);
        });
        const avgGPA = levelResults.length ? gpaTotal / levelResults.length : 0;
        let finalGrade = 'F';
        if (avgGPA >= 4.1) finalGrade = 'S'; else if (avgGPA >= 3.5) finalGrade = 'A'; else if (avgGPA >= 2.5) finalGrade = 'B'; else if (avgGPA >= 1.5) finalGrade = 'C'; else if (avgGPA >= 0.5) finalGrade = 'D';
        finalGradeTitle.innerText = `Rank: ${finalGrade}`; finalGradeTitle.className = `grade-${finalGrade}`;
    }

    function restartGame() { endScreen.style.display = "none"; levelResults = []; initLevel(0); }

    initLevel(0);
    gameLoop();

</script>
</body>
</html>
