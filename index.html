<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Pro Parking Simulator - All Levels Fixed</title>
    <style>
        body {
            background-color: #1a1a1a;
            color: #ecf0f1;
            font-family: 'Segoe UI', sans-serif;
            margin: 0;
            padding: 0;
            overflow: hidden;
            width: 100vw;
            height: 100vh;
        }
        #game-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        canvas {
            background-color: #34495e;
            display: block;
        }
        #ui-layer {
            position: absolute;
            top: 20px;
            left: 20px;
            pointer-events: none;
        }
        .hud-text {
            font-size: 18px;
            font-weight: 600;
            text-shadow: 1px 1px 2px black;
            margin-bottom: 5px;
        }
        #level-title { color: #f1c40f; font-size: 24px; }
        #status-msg { 
            position: absolute; 
            bottom: 80px; 
            width: 100%; 
            text-align: center; 
            font-size: 28px; 
            font-weight: bold;
            text-shadow: 2px 2px 4px black;
            display: none;
            pointer-events: none;
        }
        #end-screen {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.9);
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 10;
        }
        table { border-collapse: collapse; margin: 20px; width: 60%; }
        th, td { border: 1px solid #7f8c8d; padding: 10px; text-align: center; color: white; }
        th { background-color: #e67e22; }
        button {
            padding: 15px 30px;
            font-size: 20px;
            background: #27ae60;
            color: white;
            border: none;
            cursor: pointer;
            border-radius: 5px;
            pointer-events: all;
        }
        button:hover { background: #2ecc71; }
    </style>
</head>
<body>

<div id="game-container">
    <canvas id="gameCanvas"></canvas>
    
    <div id="ui-layer">
        <div id="level-title">Level 1</div>
        <div id="level-hint" class="hud-text">Hint: Park in the box</div>
        <div class="hud-text" style="margin-top: 15px; color: #bdc3c7;">
            Controls: <strong>Arrows / WASD</strong> to Drive | <strong>Space</strong> to Brake | <strong>R</strong> to Restart Level
        </div>
    </div>
    
    <div id="status-msg">PARKED!</div>

    <div id="end-screen">
        <h1 style="color: #f1c40f; font-size: 40px;">LICENSE OBTAINED!</h1>
        <h3 id="final-score-text">Total Average: 0%</h3>
        <table id="score-table">
            <thead>
                <tr>
                    <th>Level</th>
                    <th>Name</th>
                    <th>Accuracy</th>
                </tr>
            </thead>
            <tbody id="score-body"></tbody>
        </table>
        <button onclick="restartGame()">Play Again</button>
    </div>
</div>

<script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    
    const uiLevel = document.getElementById('level-title');
    const uiHint = document.getElementById('level-hint');
    const uiStatus = document.getElementById('status-msg');
    const endScreen = document.getElementById('end-screen');
    const scoreBody = document.getElementById('score-body');
    const finalScoreText = document.getElementById('final-score-text');

    function resizeCanvas() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
    }
    window.addEventListener('resize', resizeCanvas);
    resizeCanvas(); 

    const CAR_W = 26;
    const CAR_H = 48;
    const PARK_W = 36;
    const PARK_H = 60;

    function drawCar(x, y, angle, color = "#3498db", isTraffic = false) {
        ctx.save();
        ctx.translate(x, y);
        ctx.rotate(angle);

        ctx.fillStyle = "rgba(0,0,0,0.5)";
        ctx.fillRect(-CAR_W/2 + 2, -CAR_H/2 + 2, CAR_W, CAR_H);

        ctx.fillStyle = color;
        ctx.beginPath();
        ctx.roundRect(-CAR_W/2, -CAR_H/2, CAR_W, CAR_H, 4);
        ctx.fill();

        ctx.fillStyle = "#2c3e50";
        ctx.fillRect(-CAR_W/2 + 2, -CAR_H/2 + 10, CAR_W - 4, 10);
        ctx.fillRect(-CAR_W/2 + 2, CAR_H/2 - 12, CAR_W - 4, 6);

        if (!isTraffic) {
            ctx.fillStyle = "#f1c40f"; 
            ctx.fillRect(-CAR_W/2 + 2, -CAR_H/2, 6, 4);
            ctx.fillRect(CAR_W/2 - 8, -CAR_H/2, 6, 4);
            
            ctx.fillStyle = (keys.ArrowDown || keys.s || keys[" "]) ? "#ff0000" : "#7f0000";
            ctx.fillRect(-CAR_W/2 + 2, CAR_H/2 - 4, 6, 4);
            ctx.fillRect(CAR_W/2 - 8, CAR_H/2 - 4, 6, 4);
        } else {
            ctx.fillStyle = "#ecf0f1";
            ctx.fillRect(-CAR_W/2 + 2, -CAR_H/2, 6, 4);
            ctx.fillRect(CAR_W/2 - 8, -CAR_H/2, 6, 4);
            ctx.fillStyle = "#c0392b";
            ctx.fillRect(-CAR_W/2 + 2, CAR_H/2 - 4, 6, 4);
            ctx.fillRect(CAR_W/2 - 8, CAR_H/2 - 4, 6, 4);
        }

        ctx.restore();
    }

    let gameState = "PLAYING"; 
    let levelIndex = 0;
    let levelScores = [];

    const keys = { ArrowUp:false, ArrowDown:false, ArrowLeft:false, ArrowRight:false, w:false, a:false, s:false, d:false, " ":false, r:false };

    window.addEventListener('keydown', e => keys[e.key] = true);
    window.addEventListener('keyup', e => {
        keys[e.key] = false;
        if(e.key.toLowerCase() === 'r') initLevel(levelIndex);
    });

    class Car {
        constructor(x, y, angle) {
            this.x = x; this.y = y; this.angle = angle;
            this.speed = 0; this.maxSpeed = 3.5; this.friction = 0.94; 
            this.accel = 0.1; this.turnSpeed = 0.045;
        }

        update() {
            if (keys.ArrowUp || keys.w) this.speed += this.accel;
            if (keys.ArrowDown || keys.s) this.speed -= this.accel;
            if (keys[" "]) this.speed *= 0.85; 

            this.speed *= this.friction;
            if (this.speed > this.maxSpeed) this.speed = this.maxSpeed;
            if (this.speed < -this.maxSpeed/2) this.speed = -this.maxSpeed/2;
            if (Math.abs(this.speed) < 0.05) this.speed = 0;

            if (Math.abs(this.speed) > 0.1) {
                const dir = this.speed > 0 ? 1 : -1;
                if (keys.ArrowLeft || keys.a) this.angle -= this.turnSpeed * dir;
                if (keys.ArrowRight || keys.d) this.angle += this.turnSpeed * dir;
            }

            this.x += Math.sin(this.angle) * this.speed;
            this.y -= Math.cos(this.angle) * this.speed;
        }

        getPolygon() {
            return getRotatedRect(this.x, this.y, CAR_W, CAR_H, this.angle);
        }
    }

    class Traffic {
        constructor(x, y, w, h, speedX, speedY) {
            this.x = x; this.y = y; this.w = w; this.h = h;
            this.vx = speedX; this.vy = speedY;
            
            if (Math.abs(this.vy) > Math.abs(this.vx)) {
                this.angle = this.vy > 0 ? Math.PI : 0;
            } else {
                this.angle = this.vx > 0 ? Math.PI/2 : -Math.PI/2;
            }
        }
        update() {
            this.x += this.vx;
            this.y += this.vy;
            if (this.x > canvas.width + 50) this.x = -50;
            if (this.x < -50) this.x = canvas.width + 50;
            if (this.y > canvas.height + 50) this.y = -50;
            if (this.y < -50) this.y = canvas.height + 50;
        }
        draw() {
            drawCar(this.x, this.y, this.angle, "#95a5a6", true);
        }
        getPolygon() {
            return getRotatedRect(this.x, this.y, CAR_W, CAR_H, this.angle);
        }
    }

    function getRotatedRect(x, y, w, h, angle) {
        const points = [];
        const dx = w/2, dy = h/2;
        const corners = [{x:-dx, y:-dy}, {x:dx, y:-dy}, {x:dx, y:dy}, {x:-dx, y:dy}];
        for(let p of corners) {
            points.push({
                x: x + (p.x * Math.cos(angle) - p.y * Math.sin(angle)),
                y: y + (p.x * Math.sin(angle) + p.y * Math.cos(angle))
            });
        }
        return points;
    }

    function polysIntersect(poly1, poly2) {
        const polygons = [poly1, poly2];
        for (let polygon of polygons) {
            for (let i = 0; i < polygon.length; i++) {
                const p1 = polygon[i];
                const p2 = polygon[(i + 1) % polygon.length];
                const normal = { x: p2.y - p1.y, y: p1.x - p2.x }; 
                
                let minA = Infinity, maxA = -Infinity;
                for (let p of poly1) {
                    const projected = normal.x * p.x + normal.y * p.y;
                    if (projected < minA) minA = projected;
                    if (projected > maxA) maxA = projected;
                }
                
                let minB = Infinity, maxB = -Infinity;
                for (let p of poly2) {
                    const projected = normal.x * p.x + normal.y * p.y;
                    if (projected < minB) minB = projected;
                    if (projected > maxB) maxB = projected;
                }

                if (maxA < minB || maxB < minA) return false;
            }
        }
        return true;
    }

    // --- AUDITED & FIXED LEVELS DATA ---
    const levels = [
        {
            name: "1. The Basics", hint: "Drive straight in.",
            start: {x: 100, y: 550, a: 0},
            spot: {x: 100, y: 150, a: 0},
            walls: [{x: 200, y: 50, w: 20, h: 500}], 
            traffic: []
        },
        {
            name: "2. The Turn", hint: "Turn right and park.",
            start: {x: 100, y: 550, a: 0},
            // FIXED: Spot was inside the wall (x:600). Moved to 750.
            spot: {x: 750, y: 400, a: Math.PI/2},
            walls: [{x: 250, y: 250, w: 400, h: 300}], 
            traffic: []
        },
        {
            name: "3. Back It Up", hint: "Reverse parking only.",
            start: {x: 450, y: 100, a: Math.PI},
            spot: {x: 450, y: 500, a: Math.PI}, 
            // FIXED: Widened the gap slightly to avoid clipping.
            walls: [{x: 320, y: 300, w: 20, h: 250}, {x: 560, y: 300, w: 20, h: 250}],
            traffic: []
        },
        {
            name: "4. Static Traffic", hint: "Navigate the parked cars.",
            start: {x: 50, y: 325, a: Math.PI/2},
            spot: {x: 800, y: 325, a: Math.PI/2},
            walls: [
                {x: 200, y: 100, w: 30, h: 100}, {x: 200, y: 450, w: 30, h: 100},
                {x: 400, y: 200, w: 30, h: 250}, 
                // FIXED: Ensured gap is 200px (0-200, 400-600)
                {x: 600, y: 0, w: 30, h: 200}, {x: 600, y: 450, w: 30, h: 200}
            ],
            traffic: []
        },
        {
            name: "5. Highway Crossing", hint: "Watch out for cars!",
            start: {x: 450, y: 600, a: 0},
            spot: {x: 450, y: 50, a: 0},
            walls: [],
            traffic: [
                {x: 0, y: 200, vx: 4, vy: 0}, {x: 300, y: 200, vx: 4, vy: 0}, {x: 600, y: 200, vx: 4, vy: 0},
                {x: 100, y: 350, vx: -3, vy: 0}, {x: 400, y: 350, vx: -3, vy: 0}, {x: 700, y: 350, vx: -3, vy: 0},
            ]
        },
        {
            name: "6. Parallel Park", hint: "Fit between the barriers.",
            start: {x: 100, y: 350, a: Math.PI/2},
            spot: {x: 500, y: 150, a: Math.PI/2},
            walls: [
                // FIXED: Increased gap size from 140px to 200px for easier parking
                {x: 0, y: 100, w: 400, h: 100}, 
                {x: 600, y: 100, w: 400, h: 100}, 
                {x: 0, y: 0, w: 1200, h: 100} // Curb
            ],
            traffic: []
        },
        {
            name: "7. The Gauntlet", hint: "Moving traffic + Walls.",
            start: {x: 50, y: 50, a: Math.PI/2},
            spot: {x: 800, y: 550, a: Math.PI},
            walls: [{x: 300, y: 150, w: 300, h: 300}],
            traffic: [
                {x: 100, y: 100, vx: 0, vy: 2}, {x: 800, y: 500, vx: 0, vy: -2}
            ]
        },
        {
            name: "8. Diagonal Alley", hint: "Tight angled parking.",
            start: {x: 100, y: 300, a: Math.PI/2},
            spot: {x: 600, y: 150, a: Math.PI/4}, 
            walls: [
                {x: 400, y: 0, w: 20, h: 180}, // Shortened slightly
                {x: 800, y: 0, w: 20, h: 300}, // Moved right
                {x: 500, y: 300, w: 20, h: 350}
            ],
            traffic: []
        },
        {
            name: "9. Busy Lot", hint: "Cross traffic to park.",
            start: {x: 450, y: 600, a: 0},
            spot: {x: 80, y: 300, a: -Math.PI/2},
            walls: [{x: 200, y: 100, w: 500, h: 400}], 
            traffic: [
                {x: 0, y: 50, vx: 5, vy: 0},
                {x: 900, y: 550, vx: -5, vy: 0},
                {x: 50, y: 0, vx: 0, vy: 3},
                {x: 850, y: 650, vx: 0, vy: -3}
            ]
        },
        {
            name: "10. The Impossible", hint: "Don't scratch the paint.",
            start: {x: 50, y: 50, a: Math.PI/2},
            spot: {x: 820, y: 550, a: Math.PI},
            walls: [
                {x: 200, y: 0, w: 20, h: 450},
                {x: 400, y: 200, w: 20, h: 450},
                {x: 600, y: 0, w: 20, h: 450}
            ],
            traffic: [
                {x: 250, y: 500, vx: 0, vy: -6},
                {x: 500, y: 100, vx: 0, vy: 6}
            ]
        }
    ];

    let player;
    let traffic = [];
    let currentLvlData;

    function initLevel(idx) {
        if (idx >= levels.length) {
            showEndScreen();
            return;
        }
        levelIndex = idx;
        currentLvlData = levels[idx];
        gameState = "PLAYING";

        player = new Car(currentLvlData.start.x, currentLvlData.start.y, currentLvlData.start.a);
        
        traffic = [];
        if (currentLvlData.traffic) {
            currentLvlData.traffic.forEach(t => {
                traffic.push(new Traffic(t.x, t.y, CAR_W, CAR_H, t.vx, t.vy));
            });
        }

        uiLevel.innerText = currentLvlData.name;
        uiHint.innerText = currentLvlData.hint;
        uiStatus.style.display = 'none';
    }

    function checkCollision() {
        const pPoly = player.getPolygon();

        for (let w of currentLvlData.walls) {
            const wPoly = [
                {x: w.x, y: w.y}, {x: w.x+w.w, y: w.y}, 
                {x: w.x+w.w, y: w.y+w.h}, {x: w.x, y: w.y+w.h}
            ];
            if (polysIntersect(pPoly, wPoly)) return true;
        }

        for (let t of traffic) {
            const tPoly = t.getPolygon();
            if (polysIntersect(pPoly, tPoly)) return true;
        }
        
        if (player.x < 0 || player.x > canvas.width || player.y < 0 || player.y > canvas.height) return true;

        return false;
    }

    function checkWin() {
        if (Math.abs(player.speed) > 0.1) return;

        const s = currentLvlData.spot;
        const dx = player.x - s.x;
        const dy = player.y - s.y;
        const dist = Math.sqrt(dx*dx + dy*dy);

        let pAng = player.angle % (Math.PI*2);
        if (pAng < 0) pAng += Math.PI*2;
        let sAng = s.a % (Math.PI*2);
        if (sAng < 0) sAng += Math.PI*2;
        
        let angDiff = Math.abs(pAng - sAng);
        if (angDiff > Math.PI) angDiff = (Math.PI*2) - angDiff;

        if (dist < 20 && angDiff < 0.35) {
            gameState = "PARKED";
            
            let acc = Math.max(0, 100 - (dist * 2) - (angDiff * 50));
            acc = Math.floor(acc);
            
            levelScores[levelIndex] = acc;

            uiStatus.innerText = `PARKED! Accuracy: ${acc}%`;
            uiStatus.style.color = "#2ecc71";
            uiStatus.style.display = "block";
            
            setTimeout(() => {
                initLevel(levelIndex + 1);
            }, 2000);
        }
    }

    function drawScene() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        ctx.fillStyle = "#95a5a6";
        for (let w of currentLvlData.walls) {
            ctx.fillRect(w.x, w.y, w.w, w.h);
            ctx.strokeStyle = "#7f8c8d";
            ctx.lineWidth = 2;
            ctx.strokeRect(w.x, w.y, w.w, w.h);
        }

        const s = currentLvlData.spot;
        ctx.save();
        ctx.translate(s.x, s.y);
        ctx.rotate(s.a);
        
        ctx.strokeStyle = "white";
        ctx.lineWidth = 4;
        ctx.beginPath();
        ctx.moveTo(-PARK_W/2, -PARK_H/2);
        ctx.lineTo(-PARK_W/2, PARK_H/2);
        ctx.lineTo(PARK_W/2, PARK_H/2);
        ctx.lineTo(PARK_W/2, -PARK_H/2);
        ctx.stroke();

        ctx.fillStyle = "rgba(255,255,255,0.2)";
        ctx.beginPath();
        ctx.moveTo(0, -20);
        ctx.lineTo(-10, 10);
        ctx.lineTo(10, 10);
        ctx.fill();
        ctx.restore();

        traffic.forEach(t => t.draw());

        drawCar(player.x, player.y, player.angle);
    }

    function gameLoop() {
        if (gameState === "PLAYING") {
            player.update();
            traffic.forEach(t => t.update());
            
            if (checkCollision()) {
                gameState = "CRASHED";
                uiStatus.innerText = "CRASHED! Press 'R' to Restart";
                uiStatus.style.color = "#e74c3c";
                uiStatus.style.display = "block";
            } else {
                checkWin();
            }
        }
        drawScene();
        requestAnimationFrame(gameLoop);
    }

    function showEndScreen() {
        gameState = "END";
        endScreen.style.display = "flex";
        scoreBody.innerHTML = "";
        let total = 0;
        levelScores.forEach((score, i) => {
            total += score;
            const tr = document.createElement('tr');
            tr.innerHTML = `<td>${i+1}</td><td>${levels[i].name}</td><td>${score}%</td>`;
            scoreBody.appendChild(tr);
        });
        const avg = Math.floor(total / levels.length);
        finalScoreText.innerText = `Total Average: ${avg}%`;
    }

    function restartGame() {
        endScreen.style.display = "none";
        levelScores = [];
        initLevel(0);
    }

    initLevel(0);
    gameLoop();

</script>
</body>
</html>
