<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Pro Parking Simulator - Pro Edition</title>
    <style>
        body {
            background-color: #1a1a1a;
            color: #ecf0f1;
            font-family: 'Segoe UI', sans-serif;
            margin: 0;
            padding: 0;
            overflow: hidden;
            width: 100vw;
            height: 100vh;
        }
        #game-container {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
        }
        canvas {
            background-color: #34495e;
            display: block;
        }
        
        /* UI LAYOUT */
        #ui-layer {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none;
        }
        #top-left {
            position: absolute; top: 20px; left: 20px;
        }
        #top-right {
            position: absolute; top: 20px; right: 20px;
            text-align: right;
        }
        #bottom-right {
            position: absolute; bottom: 20px; right: 20px;
            text-align: right;
        }

        .hud-text {
            font-size: 18px;
            font-weight: 600;
            text-shadow: 1px 1px 2px black;
            margin-bottom: 5px;
        }
        #level-title { color: #f1c40f; font-size: 28px; font-weight: bold; }
        #level-timer { color: #e74c3c; font-size: 32px; font-family: monospace; font-weight: bold; }
        
        #controls-text {
            color: #bdc3c7;
            font-size: 16px;
            background: rgba(0,0,0,0.5);
            padding: 10px;
            border-radius: 5px;
        }

        #status-msg { 
            position: absolute; 
            bottom: 80px; 
            width: 100%; 
            text-align: center; 
            font-size: 40px; 
            font-weight: bold;
            text-shadow: 2px 2px 4px black;
            display: none;
            pointer-events: none;
            z-index: 5;
        }

        /* END SCREEN */
        #end-screen {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.95);
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 10;
        }
        table { border-collapse: collapse; margin: 20px; width: 70%; font-size: 18px; }
        th, td { border: 1px solid #7f8c8d; padding: 12px; text-align: center; color: white; }
        th { background-color: #e67e22; }
        .grade-S { color: #f1c40f; font-weight: bold; text-shadow: 0 0 5px gold; }
        .grade-A { color: #2ecc71; font-weight: bold; }
        .grade-B { color: #3498db; }
        .grade-C { color: #e67e22; }
        .grade-D { color: #95a5a6; }
        .grade-F { color: #e74c3c; }

        button {
            padding: 15px 40px;
            font-size: 24px;
            background: #27ae60;
            color: white;
            border: none;
            cursor: pointer;
            border-radius: 5px;
            pointer-events: all;
            margin-top: 20px;
        }
        button:hover { background: #2ecc71; }
    </style>
</head>
<body>

<div id="game-container">
    <canvas id="gameCanvas"></canvas>
    
    <div id="ui-layer">
        <div id="top-left">
            <div id="level-title">Level 1</div>
            <div id="level-hint" class="hud-text">Hint: Park in the box</div>
        </div>

        <div id="top-right">
            <div class="hud-text" style="color:#bdc3c7;">TIME</div>
            <div id="level-timer">00:00</div>
        </div>

        <div id="bottom-right">
            <div id="controls-text">
                <strong>Arrows / WASD</strong> Drive<br>
                <strong>Space</strong> Brake<br>
                <strong>R</strong> Restart
            </div>
        </div>
    </div>
    
    <div id="status-msg">PARKED!</div>

    <div id="end-screen">
        <h1 style="color: #f1c40f; font-size: 50px; margin: 0;">LICENSE OBTAINED!</h1>
        <h2 id="final-grade-title" style="margin-top: 10px;">Overall Rank: S</h2>
        
        <table id="score-table">
            <thead>
                <tr>
                    <th>Lvl</th>
                    <th>Name</th>
                    <th>Time</th>
                    <th>Acc</th>
                    <th>Grade</th>
                </tr>
            </thead>
            <tbody id="score-body"></tbody>
        </table>
        <button onclick="restartGame()">Play Again</button>
    </div>
</div>

<script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    
    // UI Elements
    const uiLevel = document.getElementById('level-title');
    const uiHint = document.getElementById('level-hint');
    const uiTimer = document.getElementById('level-timer');
    const uiStatus = document.getElementById('status-msg');
    const endScreen = document.getElementById('end-screen');
    const scoreBody = document.getElementById('score-body');
    const finalGradeTitle = document.getElementById('final-grade-title');

    // Canvas Resize
    function resizeCanvas() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
    }
    window.addEventListener('resize', resizeCanvas);
    resizeCanvas(); 

    // Constants
    const CAR_W = 26;
    const CAR_H = 48;
    const PARK_W = 36;
    const PARK_H = 60;

    // Drawing
    function drawCar(x, y, angle, color = "#3498db", isTraffic = false) {
        ctx.save();
        ctx.translate(x, y);
        ctx.rotate(angle);

        // Shadow
        ctx.fillStyle = "rgba(0,0,0,0.5)";
        ctx.fillRect(-CAR_W/2 + 3, -CAR_H/2 + 3, CAR_W, CAR_H);

        // Body
        ctx.fillStyle = color;
        ctx.beginPath();
        ctx.roundRect(-CAR_W/2, -CAR_H/2, CAR_W, CAR_H, 4);
        ctx.fill();

        // Windshield
        ctx.fillStyle = "#2c3e50";
        ctx.fillRect(-CAR_W/2 + 2, -CAR_H/2 + 10, CAR_W - 4, 10);
        ctx.fillRect(-CAR_W/2 + 2, CAR_H/2 - 12, CAR_W - 4, 6);

        // Lights
        if (!isTraffic) {
            ctx.fillStyle = "#f1c40f"; 
            ctx.fillRect(-CAR_W/2 + 2, -CAR_H/2, 6, 4);
            ctx.fillRect(CAR_W/2 - 8, -CAR_H/2, 6, 4);
            
            ctx.fillStyle = (keys.ArrowDown || keys.s || keys[" "]) ? "#ff0000" : "#7f0000";
            ctx.fillRect(-CAR_W/2 + 2, CAR_H/2 - 4, 6, 4);
            ctx.fillRect(CAR_W/2 - 8, CAR_H/2 - 4, 6, 4);
        } else {
            ctx.fillStyle = "#ecf0f1";
            ctx.fillRect(-CAR_W/2 + 2, -CAR_H/2, 6, 4);
            ctx.fillRect(CAR_W/2 - 8, -CAR_H/2, 6, 4);
            ctx.fillStyle = "#c0392b";
            ctx.fillRect(-CAR_W/2 + 2, CAR_H/2 - 4, 6, 4);
            ctx.fillRect(CAR_W/2 - 8, CAR_H/2 - 4, 6, 4);
        }
        ctx.restore();
    }

    // --- Physics ---
    let gameState = "PLAYING"; 
    let levelIndex = 0;
    let levelResults = []; // Stores {acc, time, grade}
    
    // Timer Variables
    let startTime = 0;
    let timerInterval = null;
    let elapsedSecs = 0;

    const keys = { ArrowUp:false, ArrowDown:false, ArrowLeft:false, ArrowRight:false, w:false, a:false, s:false, d:false, " ":false, r:false };

    window.addEventListener('keydown', e => keys[e.key] = true);
    window.addEventListener('keyup', e => {
        keys[e.key] = false;
        if(e.key.toLowerCase() === 'r') initLevel(levelIndex);
    });

    class Car {
        constructor(x, y, angle) {
            this.x = x; this.y = y; this.angle = angle;
            this.speed = 0; 
            // UPDATED SPEED STATS
            this.maxSpeed = 5.2; 
            this.friction = 0.95; 
            this.accel = 0.25; 
            this.turnSpeed = 0.055; 
        }

        update() {
            if (keys.ArrowUp || keys.w) this.speed += this.accel;
            if (keys.ArrowDown || keys.s) this.speed -= this.accel;
            if (keys[" "]) this.speed *= 0.85; 

            this.speed *= this.friction;
            if (this.speed > this.maxSpeed) this.speed = this.maxSpeed;
            if (this.speed < -this.maxSpeed/2) this.speed = -this.maxSpeed/2;
            if (Math.abs(this.speed) < 0.05) this.speed = 0;

            if (Math.abs(this.speed) > 0.1) {
                const dir = this.speed > 0 ? 1 : -1;
                if (keys.ArrowLeft || keys.a) this.angle -= this.turnSpeed * dir;
                if (keys.ArrowRight || keys.d) this.angle += this.turnSpeed * dir;
            }

            this.x += Math.sin(this.angle) * this.speed;
            this.y -= Math.cos(this.angle) * this.speed;
        }

        getPolygon() {
            return getRotatedRect(this.x, this.y, CAR_W, CAR_H, this.angle);
        }
    }

    class Traffic {
        constructor(x, y, w, h, speedX, speedY) {
            this.x = x; this.y = y; this.w = w; this.h = h;
            this.vx = speedX; this.vy = speedY;
            
            if (Math.abs(this.vy) > Math.abs(this.vx)) {
                this.angle = this.vy > 0 ? Math.PI : 0;
            } else {
                this.angle = this.vx > 0 ? Math.PI/2 : -Math.PI/2;
            }
        }
        update() {
            this.x += this.vx;
            this.y += this.vy;
            if (this.x > canvas.width + 50) this.x = -50;
            if (this.x < -50) this.x = canvas.width + 50;
            if (this.y > canvas.height + 50) this.y = -50;
            if (this.y < -50) this.y = canvas.height + 50;
        }
        draw() {
            drawCar(this.x, this.y, this.angle, "#95a5a6", true);
        }
        getPolygon() {
            return getRotatedRect(this.x, this.y, CAR_W, CAR_H, this.angle);
        }
    }

    // Geometry Helpers
    function getRotatedRect(x, y, w, h, angle) {
        const points = [];
        const dx = w/2, dy = h/2;
        const corners = [{x:-dx, y:-dy}, {x:dx, y:-dy}, {x:dx, y:dy}, {x:-dx, y:dy}];
        for(let p of corners) {
            points.push({
                x: x + (p.x * Math.cos(angle) - p.y * Math.sin(angle)),
                y: y + (p.x * Math.sin(angle) + p.y * Math.cos(angle))
            });
        }
        return points;
    }

    function polysIntersect(poly1, poly2) {
        const polygons = [poly1, poly2];
        for (let polygon of polygons) {
            for (let i = 0; i < polygon.length; i++) {
                const p1 = polygon[i];
                const p2 = polygon[(i + 1) % polygon.length];
                const normal = { x: p2.y - p1.y, y: p1.x - p2.x }; 
                
                let minA = Infinity, maxA = -Infinity;
                for (let p of poly1) {
                    const projected = normal.x * p.x + normal.y * p.y;
                    if (projected < minA) minA = projected;
                    if (projected > maxA) maxA = projected;
                }
                
                let minB = Infinity, maxB = -Infinity;
                for (let p of poly2) {
                    const projected = normal.x * p.x + normal.y * p.y;
                    if (projected < minB) minB = projected;
                    if (projected > maxB) maxB = projected;
                }
                if (maxA < minB || maxB < minA) return false;
            }
        }
        return true;
    }

    // --- LEVELS ---
    // targetTime is used for grading
    const levels = [
        {
            name: "1. The Basics", hint: "Drive straight in.", targetTime: 8,
            start: {x: 100, y: 550, a: 0},
            spot: {x: 100, y: 150, a: 0},
            walls: [{x: 200, y: 50, w: 20, h: 500}], 
            traffic: []
        },
        {
            name: "2. The Turn", hint: "Turn right and park.", targetTime: 12,
            start: {x: 100, y: 550, a: 0},
            spot: {x: 750, y: 400, a: Math.PI/2},
            walls: [{x: 250, y: 250, w: 400, h: 300}], 
            traffic: []
        },
        {
            name: "3. Back It Up", hint: "Reverse parking only.", targetTime: 15,
            start: {x: 450, y: 100, a: Math.PI},
            spot: {x: 450, y: 500, a: Math.PI}, 
            walls: [{x: 320, y: 300, w: 20, h: 250}, {x: 560, y: 300, w: 20, h: 250}],
            traffic: []
        },
        {
            name: "4. Static Traffic", hint: "Navigate the parked cars.", targetTime: 18,
            start: {x: 50, y: 325, a: Math.PI/2},
            spot: {x: 800, y: 325, a: Math.PI/2},
            walls: [
                {x: 200, y: 100, w: 30, h: 100}, {x: 200, y: 450, w: 30, h: 100},
                {x: 400, y: 200, w: 30, h: 250}, 
                {x: 600, y: 0, w: 30, h: 200}, {x: 600, y: 450, w: 30, h: 200}
            ],
            traffic: []
        },
        {
            name: "5. Highway Crossing", hint: "Watch out for cars!", targetTime: 10,
            start: {x: 450, y: 600, a: 0},
            spot: {x: 450, y: 50, a: 0},
            walls: [],
            traffic: [
                {x: 0, y: 200, vx: 4, vy: 0}, {x: 300, y: 200, vx: 4, vy: 0}, {x: 600, y: 200, vx: 4, vy: 0},
                {x: 100, y: 350, vx: -3, vy: 0}, {x: 400, y: 350, vx: -3, vy: 0}, {x: 700, y: 350, vx: -3, vy: 0},
            ]
        },
        {
            name: "6. Parallel Park", hint: "Fit between the barriers.", targetTime: 20,
            start: {x: 100, y: 350, a: Math.PI/2},
            spot: {x: 500, y: 150, a: Math.PI/2},
            walls: [
                {x: 0, y: 100, w: 400, h: 100}, 
                {x: 600, y: 100, w: 400, h: 100}, 
                {x: 0, y: 0, w: 1200, h: 100} 
            ],
            traffic: []
        },
        {
            name: "7. The Gauntlet", hint: "Moving traffic + Walls.", targetTime: 18,
            start: {x: 50, y: 50, a: Math.PI/2},
            spot: {x: 800, y: 550, a: Math.PI},
            walls: [{x: 300, y: 150, w: 300, h: 300}],
            traffic: [
                {x: 100, y: 100, vx: 0, vy: 2}, {x: 800, y: 500, vx: 0, vy: -2}
            ]
        },
        {
            name: "8. Diagonal Alley", hint: "Tight angled parking.", targetTime: 15,
            start: {x: 100, y: 300, a: Math.PI/2},
            spot: {x: 600, y: 150, a: Math.PI/4}, 
            walls: [
                {x: 400, y: 0, w: 20, h: 180},
                {x: 800, y: 0, w: 20, h: 300},
                {x: 500, y: 300, w: 20, h: 350}
            ],
            traffic: []
        },
        {
            name: "9. Busy Lot", hint: "Cross traffic to park.", targetTime: 20,
            start: {x: 450, y: 600, a: 0},
            spot: {x: 80, y: 300, a: -Math.PI/2},
            walls: [{x: 200, y: 100, w: 500, h: 400}], 
            traffic: [
                {x: 0, y: 50, vx: 5, vy: 0},
                {x: 900, y: 550, vx: -5, vy: 0},
                {x: 50, y: 0, vx: 0, vy: 3},
                {x: 850, y: 650, vx: 0, vy: -3}
            ]
        },
        {
            name: "10. The Impossible", hint: "Don't scratch the paint.", targetTime: 15,
            start: {x: 50, y: 50, a: Math.PI/2},
            spot: {x: 820, y: 550, a: Math.PI},
            walls: [
                {x: 200, y: 0, w: 20, h: 450},
                {x: 400, y: 200, w: 20, h: 450},
                {x: 600, y: 0, w: 20, h: 450}
            ],
            traffic: [
                {x: 250, y: 500, vx: 0, vy: -6},
                {x: 500, y: 100, vx: 0, vy: 6}
            ]
        },
        // --- NEW HARD LEVELS ---
        {
            name: "11. The Spiral", hint: "Follow the snail.", targetTime: 25,
            start: {x: 100, y: 550, a: 0},
            spot: {x: 450, y: 350, a: -Math.PI/2},
            walls: [
                {x: 200, y: 200, w: 20, h: 400}, // Vertical left
                {x: 200, y: 200, w: 500, h: 20}, // Top
                {x: 700, y: 200, w: 20, h: 300}, // Vertical right
                {x: 400, y: 500, w: 320, h: 20}, // Bottom
                {x: 400, y: 300, w: 20, h: 220}, // Inner Left
                {x: 400, y: 300, w: 100, h: 20}, // Inner Top
            ],
            traffic: []
        },
        {
            name: "12. Needle Thread", hint: "Don't touch the walls.", targetTime: 15,
            start: {x: 50, y: 325, a: Math.PI/2},
            spot: {x: 900, y: 325, a: Math.PI/2},
            walls: [
                {x: 0, y: 280, w: 1200, h: 20}, // Top Wall
                {x: 0, y: 350, w: 1200, h: 20}, // Bottom Wall
                // Small obstacles in the corridor
                {x: 300, y: 300, w: 10, h: 10},
                {x: 600, y: 340, w: 10, h: 10}
            ],
            traffic: []
        },
        {
            name: "13. The Maze", hint: "Zig zag.", targetTime: 30,
            start: {x: 50, y: 100, a: Math.PI/2},
            spot: {x: 900, y: 550, a: Math.PI/2},
            walls: [
                {x: 200, y: 0, w: 20, h: 450},
                {x: 450, y: 200, w: 20, h: 600},
                {x: 700, y: 0, w: 20, h: 450},
                {x: 0, y: 600, w: 200, h: 20},
                {x: 220, y: 150, w: 100, h: 20},
                {x: 550, y: 500, w: 100, h: 20}
            ],
            traffic: []
        }
    ];

    let player;
    let traffic = [];
    let currentLvlData;

    function initLevel(idx) {
        if (timerInterval) clearInterval(timerInterval);
        
        if (idx >= levels.length) {
            showEndScreen();
            return;
        }
        levelIndex = idx;
        currentLvlData = levels[idx];
        gameState = "PLAYING";

        // Reset Physics
        player = new Car(currentLvlData.start.x, currentLvlData.start.y, currentLvlData.start.a);
        
        // Traffic
        traffic = [];
        if (currentLvlData.traffic) {
            currentLvlData.traffic.forEach(t => {
                traffic.push(new Traffic(t.x, t.y, CAR_W, CAR_H, t.vx, t.vy));
            });
        }

        // UI Reset
        uiLevel.innerText = currentLvlData.name;
        uiHint.innerText = currentLvlData.hint;
        uiStatus.style.display = 'none';
        
        // Timer Start
        startTime = Date.now();
        uiTimer.innerText = "00:00";
        timerInterval = setInterval(() => {
            const delta = Date.now() - startTime;
            elapsedSecs = delta / 1000;
            const secs = Math.floor(elapsedSecs);
            const ms = Math.floor((delta % 1000) / 10);
            uiTimer.innerText = `${secs < 10 ? '0'+secs : secs}:${ms < 10 ? '0'+ms : ms}`;
        }, 50);
    }

    function checkCollision() {
        const pPoly = player.getPolygon();
        for (let w of currentLvlData.walls) {
            const wPoly = [{x: w.x, y: w.y}, {x: w.x+w.w, y: w.y}, {x: w.x+w.w, y: w.y+w.h}, {x: w.x, y: w.y+w.h}];
            if (polysIntersect(pPoly, wPoly)) return true;
        }
        for (let t of traffic) {
            if (polysIntersect(pPoly, t.getPolygon())) return true;
        }
        if (player.x < 0 || player.x > canvas.width || player.y < 0 || player.y > canvas.height) return true;
        return false;
    }

    function calculateGrade(acc, time, target) {
        // Penalty for being slow
        let timePenalty = 0;
        if (time > target) {
            timePenalty = (time - target) * 3; // Lose 3% acc per second over
        }
        
        const score = acc - timePenalty;
        
        if (score >= 95) return 'S';
        if (score >= 85) return 'A';
        if (score >= 70) return 'B';
        if (score >= 50) return 'C';
        if (score >= 30) return 'D';
        return 'F';
    }

    function checkWin() {
        if (Math.abs(player.speed) > 0.1) return;

        const s = currentLvlData.spot;
        const dx = player.x - s.x;
        const dy = player.y - s.y;
        const dist = Math.sqrt(dx*dx + dy*dy);

        let pAng = player.angle % (Math.PI*2);
        if (pAng < 0) pAng += Math.PI*2;
        let sAng = s.a % (Math.PI*2);
        if (sAng < 0) sAng += Math.PI*2;
        
        let angDiff = Math.abs(pAng - sAng);
        if (angDiff > Math.PI) angDiff = (Math.PI*2) - angDiff;

        if (dist < 20 && angDiff < 0.35) {
            clearInterval(timerInterval);
            gameState = "PARKED";
            
            // Calc Stats
            let acc = Math.max(0, 100 - (dist * 2) - (angDiff * 50));
            acc = Math.floor(acc);
            
            const grade = calculateGrade(acc, elapsedSecs, currentLvlData.targetTime);
            
            levelResults.push({
                level: levelIndex + 1,
                name: currentLvlData.name,
                time: elapsedSecs.toFixed(2),
                acc: acc,
                grade: grade
            });

            // Show HUD status
            uiStatus.innerText = `PARKED! Grade: ${grade}`;
            uiStatus.className = `grade-${grade}`; // for color
            uiStatus.style.color = getGradeColor(grade);
            uiStatus.style.display = "block";
            
            setTimeout(() => {
                initLevel(levelIndex + 1);
            }, 2500);
        }
    }

    function getGradeColor(g) {
        if(g==='S') return '#f1c40f';
        if(g==='A') return '#2ecc71';
        if(g==='B') return '#3498db';
        if(g==='C') return '#e67e22';
        return '#e74c3c';
    }

    function drawScene() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // Walls
        ctx.fillStyle = "#95a5a6";
        for (let w of currentLvlData.walls) {
            ctx.fillRect(w.x, w.y, w.w, w.h);
            ctx.strokeStyle = "#7f8c8d";
            ctx.lineWidth = 2;
            ctx.strokeRect(w.x, w.y, w.w, w.h);
        }

        // Spot
        const s = currentLvlData.spot;
        ctx.save();
        ctx.translate(s.x, s.y);
        ctx.rotate(s.a);
        ctx.strokeStyle = "white";
        ctx.lineWidth = 4;
        ctx.beginPath();
        ctx.moveTo(-PARK_W/2, -PARK_H/2);
        ctx.lineTo(-PARK_W/2, PARK_H/2);
        ctx.lineTo(PARK_W/2, PARK_H/2);
        ctx.lineTo(PARK_W/2, -PARK_H/2);
        ctx.stroke();
        // Arrow
        ctx.fillStyle = "rgba(255,255,255,0.2)";
        ctx.beginPath();
        ctx.moveTo(0, -20);
        ctx.lineTo(-10, 10);
        ctx.lineTo(10, 10);
        ctx.fill();
        ctx.restore();

        traffic.forEach(t => t.draw());
        drawCar(player.x, player.y, player.angle);
    }

    function gameLoop() {
        if (gameState === "PLAYING") {
            player.update();
            traffic.forEach(t => t.update());
            
            if (checkCollision()) {
                gameState = "CRASHED";
                clearInterval(timerInterval);
                uiStatus.innerText = "CRASHED! Press 'R'";
                uiStatus.style.color = "#e74c3c";
                uiStatus.style.display = "block";
            } else {
                checkWin();
            }
        }
        drawScene();
        requestAnimationFrame(gameLoop);
    }

    function showEndScreen() {
        gameState = "END";
        endScreen.style.display = "flex";
        scoreBody.innerHTML = "";
        
        let gpaTotal = 0;
        const gpaMap = {'S':4.3, 'A':4.0, 'B':3.0, 'C':2.0, 'D':1.0, 'F':0};

        levelResults.forEach(res => {
            gpaTotal += gpaMap[res.grade] || 0;
            const tr = document.createElement('tr');
            tr.innerHTML = `
                <td>${res.level}</td>
                <td>${res.name}</td>
                <td>${res.time}s</td>
                <td>${res.acc}%</td>
                <td class="grade-${res.grade}">${res.grade}</td>
            `;
            scoreBody.appendChild(tr);
        });

        // Calculate Final Grade
        const avgGPA = gpaTotal / levelResults.length;
        let finalGrade = 'F';
        if (avgGPA >= 4.1) finalGrade = 'S';
        else if (avgGPA >= 3.5) finalGrade = 'A';
        else if (avgGPA >= 2.5) finalGrade = 'B';
        else if (avgGPA >= 1.5) finalGrade = 'C';
        else if (avgGPA >= 0.5) finalGrade = 'D';

        finalGradeTitle.innerText = `Overall Rank: ${finalGrade}`;
        finalGradeTitle.className = `grade-${finalGrade}`;
    }

    function restartGame() {
        endScreen.style.display = "none";
        levelResults = [];
        initLevel(0);
    }

    initLevel(0);
    gameLoop();

</script>
</body>
</html>
